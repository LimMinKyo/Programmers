# 2개 이하로 다른 비트

이 코드는 비트 연산을 사용하여 각 수의 f(x) 값을 계산합니다.

```python
def solution(numbers):
    return [(((number ^ (number + 1)) >> 2) + number + 1) for number in numbers]
```

## 코드 해석

1. `number ^ (number + 1)`: XOR 연산으로 number과 number + 1 사이에 다른 비트를 찾습니다. XOR은 두 비트가 다를 때 1을 반환합니다.

2. `>> 2`: 오른쪽으로 2비트 시프트합니다.

3. `+ number + 1`: 결과에 number+1을 더합니다.

## 동작 원리

이 코드가 작동하는 원리:

- 어떤 수 x와 다음 수 x+1 사이의 XOR은 최하위 비트부터 연속된 1들을 생성합니다.
- 이 결과를 2비트 오른쪽으로 시프트한 후 x+1을 더하면, x보다 크고 x와 비트가 1-2개 다른 가장 작은 수를 얻게 됩니다.

예시로 확인:
- f(2) = ((2 ^ 3) >> 2) + 2 + 1 = (1 >> 2) + 3 = 0 + 3 = 3
- f(7) = ((7 ^ 8) >> 2) + 7 + 1 = (15 >> 2) + 8 = 3 + 8 = 11

이 알고리즘은 문제의 요구사항을 효율적으로 해결합니다 - 각 수보다 크고 비트가 1-2개 다른 가장 작은 수를 찾습니다.

## 상세 예시

### 예시 1: f(2)를 계산해봅시다

1) 먼저 2와 3의 이진수를 살펴보겠습니다:
   - 2 = 10(2)
   - 3 = 11(2)

2) `number ^ (number + 1)` 부분: 2 ^ 3 계산
   - 10(2) XOR 11(2) = 01(2) = 1(10)
   - XOR은 같은 비트는 0, 다른 비트는 1이 됩니다

3) `>> 2` 부분: 오른쪽으로 2비트 이동
   - 01(2) >> 2 = 00(2) = 0(10)
   - 1비트만 있었기 때문에 2비트 오른쪽 이동하면 0이 됩니다

4) `+ number + 1` 부분: 0 + 2 + 1 = 3
   - 최종 결과 f(2) = 3

### 예시 2: f(7)을 계산해봅시다

1) 7과 8의 이진수:
   - 7 = 0111(2)
   - 8 = 1000(2)

2) `number ^ (number + 1)` 부분: 7 ^ 8 계산
   - 0111(2) XOR 1000(2) = 1111(2) = 15(10)
   - 모든 비트가 다르므로 모든 자리가 1이 됩니다

3) `>> 2` 부분: 오른쪽으로 2비트 이동
   - 1111(2) >> 2 = 0011(2) = 3(10)

4) `+ number + 1` 부분: 3 + 7 + 1 = 11
   - 최종 결과 f(7) = 11

### 예시 3: f(5)도 해보겠습니다

1) 5와 6의 이진수:
   - 5 = 101(2)
   - 6 = 110(2)

2) `number ^ (number+1)` 부분: 5 ^ 6 계산
   - 101(2) XOR 110(2) = 011(2) = 3(10)

3) `>> 2` 부분: 오른쪽으로 2비트 이동
   - 011(2) >> 2 = 000(2) = 0(10)

4) `+ number + 1` 부분: 0 + 5 + 1 = 6
   - 최종 결과 f(5) = 6

## 알고리즘 작동 원리 설명

이 알고리즘이 작동하는 이유는 다음과 같습니다:

1. 어떤 수 x에서 x+1로 넘어갈 때, 가장 낮은 자리의 0이 1로 바뀌고 그 오른쪽의 모든 1은 0으로 바뀝니다.
2. 따라서 x와 x+1의 XOR은 이 변화가 있는 모든 비트에 1을 표시합니다.
3. 이를 2비트 오른쪽으로 이동하면 "변화량"이 줄어듭니다.
4. 여기에 x+1을 더하면 x보다 크면서 비트 차이가 적은 수를 찾게 됩니다.

이것이 문제에서 요구하는 "x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수"를 찾는 효율적인 방법입니다.
